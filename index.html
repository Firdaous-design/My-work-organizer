<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Business Manager</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f3f4f6;
            color: #1f2937;
        }
        .container {
            max-width: 1200px;
            margin: auto;
            padding: 2rem;
        }
        .card {
            background-color: #fff;
            border-radius: 1.5rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            padding: 2rem;
        }
        .btn {
            @apply px-6 py-3 font-semibold rounded-full transition-colors duration-200;
        }
        .btn-primary {
            @apply bg-indigo-600 text-white hover:bg-indigo-700;
        }
        .btn-secondary {
            @apply bg-gray-200 text-gray-800 hover:bg-gray-300;
        }
        .input-group {
            @apply mb-4;
        }
        .input-group label {
            @apply block text-gray-700 font-medium mb-1;
        }
        .input-group input, .input-group textarea, .input-group select {
            @apply w-full border border-gray-300 rounded-lg p-3 focus:outline-none focus:ring-2 focus:ring-indigo-500;
        }
        .modal {
            @apply fixed inset-0 flex items-center justify-center bg-gray-900 bg-opacity-75 z-50 transition-opacity duration-300;
        }
        .modal-content {
            @apply bg-white p-8 rounded-2xl shadow-xl max-w-lg w-full transform scale-95 transition-transform duration-300;
        }
        .tab-content {
            display: none;
        }
        .tab-content.active {
            display: block;
        }
        .tab-button.active {
            @apply bg-indigo-100 text-indigo-700 font-bold;
        }
        #notesOutput p, #notesOutput ul {
            margin-bottom: 1rem;
        }
        #notesOutput ul {
            list-style-type: disc;
            padding-left: 20px;
        }
    </style>
</head>
<body class="bg-gray-100">

    <div class="container py-8">
        <header class="text-center mb-8">
            <h1 class="text-4xl font-extrabold text-indigo-800">AI Business Manager</h1>
            <p class="text-lg text-gray-600 mt-2">Votre assistant intelligent pour la gestion client et de projet.</p>
        </header>

        <div class="card mb-8">
            <div class="flex border-b border-gray-200 mb-6 flex-wrap">
                <button class="tab-button px-4 py-2 -mb-px rounded-t-lg transition-colors duration-200" data-tab="find-slot">Trouver un créneau</button>
                <button class="tab-button px-4 py-2 -mb-px rounded-t-lg transition-colors duration-200" data-tab="schedule-meeting">Planifier la réunion</button>
                <button class="tab-button px-4 py-2 -mb-px rounded-t-lg transition-colors duration-200" data-tab="manage-notes">Gérer les notes</button>
                <button class="tab-button px-4 py-2 -mb-px rounded-t-lg transition-colors duration-200" data-tab="create-contract">Créer un contrat</button>
                <button class="tab-button px-4 py-2 -mb-px rounded-t-lg transition-colors duration-200" data-tab="client-folder">Dossier client</button>
                <button class="tab-button px-4 py-2 -mb-px rounded-t-lg transition-colors duration-200" data-tab="calendar-manager">Gestionnaire de calendrier</button>
                <button class="tab-button px-4 py-2 -mb-px rounded-t-lg transition-colors duration-200" data-tab="project-generator">Générer une idée de projet</button>
            </div>

            <!-- Find Time Slot Tab -->
            <div id="find-slot" class="tab-content active">
                <h2 class="text-2xl font-bold mb-4">Trouver un créneau disponible</h2>
                <div class="input-group">
                    <label for="client-name">Nom du client</label>
                    <input type="text" id="client-name" placeholder="Nom du client" class="w-full">
                </div>
                <div class="input-group">
                    <label for="meeting-duration">Durée de la réunion (en minutes)</label>
                    <input type="number" id="meeting-duration" value="60" min="15" step="15" class="w-full">
                </div>
                <div class="input-group">
                    <label for="preferred-days">Jours préférés (ex: Lundi, Mercredi)</label>
                    <input type="text" id="preferred-days" placeholder="Lundi, Mercredi" class="w-full">
                </div>
                <div class="input-group">
                    <label for="busy-slots">Créneaux déjà pris (format JSON)</label>
                    <textarea id="busy-slots" rows="4" placeholder='[{"day": "Lundi", "start": "09:00", "end": "10:30"}]' class="w-full"></textarea>
                </div>
                <button id="find-slot-btn" class="btn btn-primary">Rechercher</button>
                <div id="slots-output" class="mt-4 p-4 bg-gray-50 rounded-lg border border-gray-200 hidden">
                    <h3 class="font-semibold text-lg">Créneaux trouvés :</h3>
                    <ul id="available-slots-list" class="list-disc pl-5 mt-2 text-gray-700"></ul>
                </div>
            </div>

            <!-- Schedule Meeting Tab -->
            <div id="schedule-meeting" class="tab-content">
                <h2 class="text-2xl font-bold mb-4">Planifier la réunion</h2>
                <div class="input-group">
                    <label for="schedule-client-name">Nom du client</label>
                    <input type="text" id="schedule-client-name" placeholder="Nom du client" class="w-full">
                </div>
                <div class="input-group">
                    <label for="schedule-date">Date de la réunion</label>
                    <input type="date" id="schedule-date" class="w-full">
                </div>
                <div class="input-group">
                    <label for="schedule-time">Heure de la réunion</label>
                    <input type="time" id="schedule-time" class="w-full">
                </div>
                <div class="input-group">
                    <label for="schedule-notes">Notes de la réunion</label>
                    <textarea id="schedule-notes" rows="4" placeholder="Objectifs de la réunion, etc." class="w-full"></textarea>
                </div>
                <button id="schedule-meeting-btn" class="btn btn-primary">Planifier</button>
            </div>

            <!-- Manage Meeting Notes Tab -->
            <div id="manage-notes" class="tab-content">
                <h2 class="text-2xl font-bold mb-4">Générer des notes de réunion</h2>
                <div class="input-group">
                    <label for="meeting-transcript">Transcription de la réunion</label>
                    <textarea id="meeting-transcript" rows="6" placeholder="Copiez-collez la transcription de votre réunion ici..." class="w-full"></textarea>
                </div>
                <div class="flex gap-4">
                    <button id="generate-notes-btn" class="btn btn-primary">Générer les notes</button>
                    <button id="read-notes-btn" class="btn btn-secondary">Lire les notes ✨</button>
                </div>
                <div id="notes-output" class="mt-4 p-4 bg-gray-50 rounded-lg border border-gray-200">
                    <h3 class="font-semibold text-lg mb-2">Notes générées :</h3>
                    <div id="notesOutput" class="prose max-w-full"></div>
                </div>
            </div>

            <!-- Create Contract Tab -->
            <div id="create-contract" class="tab-content">
                <h2 class="text-2xl font-bold mb-4">Créer un contrat personnalisé</h2>
                <div class="input-group">
                    <label for="contract-client-name">Nom du client</label>
                    <input type="text" id="contract-client-name" placeholder="Nom du client" class="w-full">
                </div>
                <div class="input-group">
                    <label for="service-details">Détails du service (basé sur les notes de réunion)</label>
                    <textarea id="service-details" rows="6" placeholder="Décrivez les services à inclure dans le contrat..." class="w-full"></textarea>
                </div>
                <div class="input-group">
                    <label for="contract-template">Modèle de contrat (facultatif)</label>
                    <textarea id="contract-template" rows="6" placeholder="Collez votre modèle de contrat ici. L'IA le remplira avec les détails du service." class="w-full"></textarea>
                </div>
                <button id="generate-contract-btn" class="btn btn-primary">Générer le contrat</button>
                <div id="contract-output" class="mt-4 p-4 bg-gray-50 rounded-lg border border-gray-200">
                    <h3 class="font-semibold text-lg mb-2">Contrat généré :</h3>
                    <div id="contractOutput" class="prose max-w-full"></div>
                </div>
            </div>

            <!-- Client Folder Tab -->
            <div id="client-folder" class="tab-content">
                <h2 class="text-2xl font-bold mb-4">Dossier client</h2>
                <div class="input-group">
                    <label for="select-client-folder">Sélectionner un client</label>
                    <select id="select-client-folder" class="w-full">
                        <option value="">-- Sélectionnez un client --</option>
                    </select>
                </div>
                <div id="client-folder-details" class="mt-4 p-4 bg-gray-50 rounded-lg border border-gray-200 hidden">
                    <h3 class="font-semibold text-lg mb-2">Détails du dossier</h3>
                    <div id="folder-content"></div>
                </div>
            </div>

            <!-- Calendar Manager Tab -->
            <div id="calendar-manager" class="tab-content">
                <h2 class="text-2xl font-bold mb-4">Gestionnaire de calendrier AI</h2>
                <div class="input-group">
                    <label for="calendar-prompt">Décrivez une tâche ou un objectif</label>
                    <textarea id="calendar-prompt" rows="4" placeholder="Ex: 'Planifier des posts sur les réseaux sociaux pour les trois prochaines semaines. Je veux 3 posts par semaine sur Instagram, les mardis et jeudis, et un le samedi. Les sujets sont le design minimaliste et les astuces de rangement.' ou 'Je dois finir la proposition pour le client Smith avant vendredi. Aide-moi à gérer mon temps.'" class="w-full"></textarea>
                </div>
                <button id="manage-calendar-btn" class="btn btn-primary">Gérer le calendrier</button>
                <div id="calendar-output" class="mt-4 p-4 bg-gray-50 rounded-lg border border-gray-200">
                    <h3 class="font-semibold text-lg mb-2">Suggestions AI :</h3>
                    <div id="calendarOutput" class="prose max-w-full"></div>
                </div>
            </div>

            <!-- Project Idea Generator Tab -->
            <div id="project-generator" class="tab-content">
                <h2 class="text-2xl font-bold mb-4">Générer une idée de projet ✨</h2>
                <div class="input-group">
                    <label for="project-name">Nom du client</label>
                    <input type="text" id="project-name" placeholder="Nom du client" class="w-full">
                </div>
                <div class="input-group">
                    <label for="project-idea">Décrivez l'idée de projet</label>
                    <textarea id="project-idea" rows="6" placeholder="Ex: 'Un site web de e-commerce pour vendre des œuvres d'art numériques.'" class="w-full"></textarea>
                </div>
                <button id="generate-project-idea-btn" class="btn btn-primary">Générer le plan de projet</button>
                <div id="project-output" class="mt-4 p-4 bg-gray-50 rounded-lg border border-gray-200">
                    <h3 class="font-semibold text-lg mb-2">Plan de projet généré :</h3>
                    <div id="projectOutput" class="prose max-w-full"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Modals -->
    <div id="message-modal" class="modal hidden">
        <div class="modal-content">
            <h3 id="modal-title" class="text-xl font-bold mb-4"></h3>
            <p id="modal-message" class="mb-6"></p>
            <div class="flex justify-end">
                <button id="close-modal-btn" class="btn btn-secondary">Fermer</button>
            </div>
        </div>
    </div>
    <div id="loading-modal" class="modal hidden">
        <div class="modal-content text-center">
            <div class="flex items-center justify-center">
                <svg class="animate-spin -ml-1 mr-3 h-8 w-8 text-indigo-600" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                    <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                    <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                </svg>
                <span class="text-lg font-medium text-gray-700">Chargement en cours...</span>
            </div>
        </div>
    </div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, setDoc, onSnapshot, collection, query, getDocs, setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // Firebase is automatically configured and authenticated by the Canvas environment.
        // The __app_id, __firebase_config, and __initial_auth_token are provided at runtime.
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'the-time-manager';
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {};
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

        let db, auth, userId;

        // UI elements
        const loadingModal = document.getElementById('loading-modal');
        const messageModal = document.getElementById('message-modal');
        const modalTitle = document.getElementById('modal-title');
        const modalMessage = document.getElementById('modal-message');
        const closeModalBtn = document.getElementById('close-modal-btn');
        const tabButtons = document.querySelectorAll('.tab-button');
        const tabContents = document.querySelectorAll('.tab-content');

        // Initialize Firebase
        const app = initializeApp(firebaseConfig);
        db = getFirestore(app);
        auth = getAuth(app);
        setLogLevel('debug');

        // API Key for Gemini API (left empty, will be provided at runtime)
        const apiKey = "AIzaSyAe_eysrsB4TrRuVUT4s34rNe2e0weGyuI";

        // Authentication State Listener
        onAuthStateChanged(auth, async (user) => {
            if (user) {
                userId = user.uid;
            } else {
                if (initialAuthToken) {
                    try {
                        await signInWithCustomToken(auth, initialAuthToken);
                        userId = auth.currentUser.uid;
                    } catch (error) {
                        console.error("Custom token sign-in failed, signing in anonymously:", error);
                        await signInAnonymously(auth);
                        userId = auth.currentUser.uid;
                    }
                } else {
                    await signInAnonymously(auth);
                    userId = auth.currentUser.uid;
                }
            }
            console.log("Authenticated with user ID:", userId);
            fetchClientsForSelect();
        });

        function showLoading(message = 'Chargement en cours...') {
            loadingModal.querySelector('span').textContent = message;
            loadingModal.classList.remove('hidden');
            setTimeout(() => {
                loadingModal.classList.add('opacity-100');
            }, 10);
        }

        function hideLoading() {
            loadingModal.classList.add('hidden');
            loadingModal.classList.remove('opacity-100');
        }

        function showMessage(title, message) {
            modalTitle.textContent = title;
            modalMessage.textContent = message;
            messageModal.classList.remove('hidden');
            setTimeout(() => {
                messageModal.classList.add('opacity-100');
            }, 10);
        }

        closeModalBtn.onclick = () => {
            messageModal.classList.add('hidden');
            messageModal.classList.remove('opacity-100');
        };

        // Tab functionality
        tabButtons.forEach(button => {
            button.addEventListener('click', () => {
                const targetTab = button.dataset.tab;

                tabButtons.forEach(btn => btn.classList.remove('active'));
                button.classList.add('active');

                tabContents.forEach(content => content.classList.remove('active'));
                document.getElementById(targetTab).classList.add('active');

                if (targetTab === 'client-folder') {
                    fetchClientsForSelect();
                }
            });
        });
        document.querySelector('.tab-button').click(); // Activate first tab on load

        // Firestore paths
        const getClientDocRef = (clientId) => doc(db, 'artifacts', appId, 'users', userId, 'clients', clientId);
        const getClientCollectionRef = () => collection(db, 'artifacts', appId, 'users', userId, 'clients');

        async function fetchClientsForSelect() {
            const select = document.getElementById('select-client-folder');
            select.innerHTML = '<option value="">-- Sélectionnez un client --</option>';
            try {
                if (!userId) return;
                const q = query(getClientCollectionRef());
                const querySnapshot = await getDocs(q);
                querySnapshot.forEach((doc) => {
                    const client = doc.data();
                    const option = document.createElement('option');
                    option.value = doc.id;
                    option.textContent = client.name;
                    select.appendChild(option);
                });
            } catch (error) {
                console.error("Error fetching clients: ", error);
            }
        }

        // Feature 1: Find an available time slot
        document.getElementById('find-slot-btn').addEventListener('click', async () => {
            const clientName = document.getElementById('client-name').value;
            const duration = parseInt(document.getElementById('meeting-duration').value);
            const preferredDays = document.getElementById('preferred-days').value;
            const busySlotsRaw = document.getElementById('busy-slots').value;
            
            if (!clientName || !duration || !preferredDays) {
                showMessage("Erreur", "Veuillez remplir le nom du client, la durée et les jours préférés.");
                return;
            }

            let busySlots = [];
            try {
                busySlots = JSON.parse(busySlotsRaw);
            } catch (e) {
                showMessage("Erreur de format", "Le JSON des créneaux pris n'est pas valide. Veuillez vérifier le format.");
                return;
            }

            showLoading("Recherche de créneaux disponibles...");

            const systemPrompt = `
                Tu es un assistant IA spécialisé dans la planification de réunions.
                Ton objectif est de trouver et de suggérer les meilleurs créneaux horaires pour une réunion, en tenant compte des informations fournies.
                Le format de la réponse doit être une liste de 3 à 5 créneaux sous forme d'une liste à puces. Pour chaque créneau, indique clairement le jour, la date et l'heure de début et de fin.
                Utilise le format "Jour, JJ Mois - HH:mm à HH:mm".
                Assure-toi que les créneaux suggérés sont réalistes et ne chevauchent pas les heures déjà occupées.
                Toutes les suggestions doivent être en français.
            `;
            const userQuery = `
                Trouve 3 à 5 créneaux horaires disponibles pour une réunion avec le client "${clientName}".
                La réunion doit durer ${duration} minutes.
                Les jours de la semaine préférés pour la réunion sont : ${preferredDays}.
                Voici mes créneaux déjà pris (à éviter) : ${JSON.stringify(busySlots)}.
            `;

            try {
                const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        contents: [{ parts: [{ text: userQuery }] }],
                        systemInstruction: { parts: [{ text: systemPrompt }] },
                    })
                });

                const result = await response.json();
                const text = result.candidates?.[0]?.content?.parts?.[0]?.text;
                
                if (text) {
                    const output = document.getElementById('available-slots-list');
                    output.innerHTML = marked.parse(text);
                    document.getElementById('slots-output').classList.remove('hidden');
                } else {
                    showMessage("Aucun résultat", "Impossible de trouver des créneaux pour le moment. Veuillez réessayer.");
                }
            } catch (error) {
                console.error("Error finding slot:", error);
                showMessage("Erreur de connexion", "Une erreur est survenue lors de la communication avec le service AI. Veuillez réessayer plus tard.");
            } finally {
                hideLoading();
            }
        });

        // Feature 2: Schedule a meeting
        document.getElementById('schedule-meeting-btn').addEventListener('click', async () => {
            const clientName = document.getElementById('schedule-client-name').value;
            const date = document.getElementById('schedule-date').value;
            const time = document.getElementById('schedule-time').value;
            const notes = document.getElementById('schedule-notes').value;
            
            if (!clientName || !date || !time) {
                showMessage("Erreur", "Veuillez remplir tous les champs.");
                return;
            }

            showLoading("Planification de la réunion...");

            const meeting = { clientName, date, time, notes, type: 'meeting' };

            try {
                if (!userId) {
                    showMessage("Erreur", "Authentification non terminée. Veuillez patienter.");
                    hideLoading();
                    return;
                }
                const clientDocRef = doc(db, 'artifacts', appId, 'users', userId, 'clients', clientName);
                const clientDoc = await getDoc(clientDocRef);
                
                let meetings = [];
                if (clientDoc.exists()) {
                    meetings = clientDoc.data().meetings || [];
                }

                meetings.push(meeting);
                
                await setDoc(clientDocRef, { name: clientName, meetings: meetings }, { merge: true });
                showMessage("Succès", `Réunion avec ${clientName} planifiée pour le ${date} à ${time}.`);
            } catch (error) {
                console.error("Error scheduling meeting:", error);
                showMessage("Erreur", "Impossible de planifier la réunion. Veuillez réessayer.");
            } finally {
                hideLoading();
            }
        });

        // Feature 3: Generate meeting notes
        document.getElementById('generate-notes-btn').addEventListener('click', async () => {
            const transcript = document.getElementById('meeting-transcript').value;
            if (!transcript) {
                showMessage("Erreur", "Veuillez entrer une transcription de réunion.");
                return;
            }

            showLoading("Génération des notes de réunion...");

            const systemPrompt = `
                Tu es un assistant IA spécialisé dans la prise de notes de réunion.
                Ton objectif est d'analyser la transcription d'une réunion et de la synthétiser en une note concise et structurée.
                Les notes doivent contenir les points clés, les décisions prises et les prochaines étapes.
                Le format de la réponse doit être en Markdown, avec des titres, des sous-titres et des listes à puces.
                Utilise une approche analytique et objective.
                La réponse doit être en français.
            `;
            const userQuery = `
                Voici une transcription de réunion. Génère des notes claires et concises, en mettant en évidence les points clés, les décisions et les actions à entreprendre.

                Transcription:
                ${transcript}
            `;

            try {
                const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        contents: [{ parts: [{ text: userQuery }] }],
                        systemInstruction: { parts: [{ text: systemPrompt }] },
                    })
                });

                const result = await response.json();
                const text = result.candidates?.[0]?.content?.parts?.[0]?.text;

                if (text) {
                    document.getElementById('notesOutput').innerHTML = marked.parse(text);
                } else {
                    showMessage("Aucun résultat", "Impossible de générer des notes pour le moment.");
                }
            } catch (error) {
                console.error("Error generating notes:", error);
                showMessage("Erreur de connexion", "Une erreur est survenue lors de la communication avec le service AI. Veuillez réessayer plus tard.");
            } finally {
                hideLoading();
            }
        });

        // New Feature: Text-to-Speech for notes
        document.getElementById('read-notes-btn').addEventListener('click', async () => {
            const notesText = document.getElementById('notesOutput').innerText;
            if (!notesText || notesText.trim() === '') {
                showMessage("Erreur", "Veuillez d'abord générer des notes.");
                return;
            }

            showLoading("Lecture des notes...");

            try {
                const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-tts:generateContent?key=${apiKey}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        contents: [{ parts: [{ text: notesText }] }],
                        generationConfig: {
                            responseModalities: ["AUDIO"],
                            speechConfig: {
                                voiceConfig: { prebuiltVoiceConfig: { voiceName: "Puck" } }
                            }
                        }
                    })
                });

                const result = await response.json();
                const part = result?.candidates?.[0]?.content?.parts?.[0];
                const audioData = part?.inlineData?.data;
                const mimeType = part?.inlineData?.mimeType;

                if (audioData && mimeType && mimeType.startsWith("audio/")) {
                    // Helper function to decode base64
                    const base64ToArrayBuffer = (base64) => {
                        const binaryString = atob(base64);
                        const len = binaryString.length;
                        const bytes = new Uint8Array(len);
                        for (let i = 0; i < len; i++) {
                            bytes[i] = binaryString.charCodeAt(i);
                        }
                        return bytes.buffer;
                    };

                    // Helper function to create a WAV blob from PCM data
                    const pcmToWav = (pcmData, sampleRate) => {
                        const buffer = new ArrayBuffer(44 + pcmData.length * 2);
                        const view = new DataView(buffer);

                        // RIFF identifier
                        writeString(view, 0, 'RIFF');
                        // file length
                        view.setUint32(4, 36 + pcmData.length * 2, true);
                        // RIFF type
                        writeString(view, 8, 'WAVE');
                        // format chunk identifier
                        writeString(view, 12, 'fmt ');
                        // format chunk length
                        view.setUint32(16, 16, true);
                        // sample format (1 = PCM)
                        view.setUint16(20, 1, true);
                        // channel count
                        view.setUint16(22, 1, true);
                        // sample rate
                        view.setUint32(24, sampleRate, true);
                        // byte rate (sample rate * block align)
                        view.setUint32(28, sampleRate * 2, true);
                        // block align
                        view.setUint16(32, 2, true);
                        // bits per sample
                        view.setUint16(34, 16, true);
                        // data chunk identifier
                        writeString(view, 36, 'data');
                        // data chunk length
                        view.setUint32(40, pcmData.length * 2, true);
                        
                        // Write PCM samples
                        for (let i = 0; i < pcmData.length; i++) {
                            view.setInt16(44 + i * 2, pcmData[i], true);
                        }
                        return new Blob([view], { type: 'audio/wav' });
                    };

                    const writeString = (view, offset, string) => {
                        for (let i = 0; i < string.length; i++) {
                            view.setUint8(offset + i, string.charCodeAt(i));
                        }
                    };

                    const sampleRate = parseInt(mimeType.match(/rate=(\d+)/)[1], 10);
                    const pcmData = new Int16Array(base64ToArrayBuffer(audioData));
                    const wavBlob = pcmToWav(pcmData, sampleRate);
                    const audioUrl = URL.createObjectURL(wavBlob);
                    const audio = new Audio(audioUrl);
                    audio.play();
                } else {
                    showMessage("Erreur", "Impossible de lire le texte. Le format audio est invalide.");
                }
            } catch (error) {
                console.error("Error reading notes:", error);
                showMessage("Erreur de connexion", "Une erreur est survenue lors de la communication avec le service TTS.");
            } finally {
                hideLoading();
            }
        });

        // Feature 4: Create a custom contract
        document.getElementById('generate-contract-btn').addEventListener('click', async () => {
            const clientName = document.getElementById('contract-client-name').value;
            const serviceDetails = document.getElementById('service-details').value;
            const contractTemplate = document.getElementById('contract-template').value;

            if (!clientName || !serviceDetails) {
                showMessage("Erreur", "Veuillez entrer le nom du client et les détails du service.");
                return;
            }

            showLoading("Génération du contrat...");

            const systemPrompt = `
                Tu es un assistant IA juridique spécialisé dans la rédaction de contrats de services pour les professionnels indépendants.
                Ton objectif est de remplir un modèle de contrat fourni ou de créer un contrat si aucun modèle n'est fourni.
                Le contrat final doit être simple, clair, professionnel et rédigé de manière formelle.
                Utilise le format Markdown pour la mise en page.
            `;
            
            let userQuery;
            if (contractTemplate) {
                userQuery = `
                    En utilisant le modèle de contrat suivant, remplis les informations manquantes en te basant sur les détails du service pour le client "${clientName}".

                    Détails du service :
                    ${serviceDetails}

                    Modèle de contrat :
                    ${contractTemplate}
                `;
            } else {
                userQuery = `
                    Génère un contrat de service pour le client "${clientName}" basé sur les détails suivants :
                    ${serviceDetails}
                `;
            }

            try {
                const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        contents: [{ parts: [{ text: userQuery }] }],
                        systemInstruction: { parts: [{ text: systemPrompt }] },
                    })
                });

                const result = await response.json();
                const text = result.candidates?.[0]?.content?.parts?.[0]?.text;

                if (text) {
                    document.getElementById('contractOutput').innerHTML = marked.parse(text);
                    // Save contract to Firestore
                    if (!userId) {
                        showMessage("Erreur", "Authentification non terminée. Veuillez patienter.");
                        hideLoading();
                        return;
                    }
                    const clientDocRef = doc(db, 'artifacts', appId, 'users', userId, 'clients', clientName);
                    const clientDoc = await getDoc(clientDocRef);
                    let contracts = [];
                    if (clientDoc.exists()) {
                        contracts = clientDoc.data().contracts || [];
                    }
                    contracts.push({ date: new Date().toISOString(), content: text });
                    await setDoc(clientDocRef, { name: clientName, contracts: contracts }, { merge: true });

                    showMessage("Succès", `Contrat pour ${clientName} généré et sauvegardé dans son dossier.`);
                } else {
                    showMessage("Aucun résultat", "Impossible de générer le contrat pour le moment.");
                }
            } catch (error) {
                console.error("Error generating contract:", error);
                showMessage("Erreur de connexion", "Une erreur est survenue lors de la communication avec le service AI. Veuillez réessayer plus tard.");
            } finally {
                hideLoading();
            }
        });

        // Feature 5: Client Folder
        document.getElementById('select-client-folder').addEventListener('change', async (e) => {
            const clientId = e.target.value;
            const folderContent = document.getElementById('folder-content');
            const folderDetails = document.getElementById('client-folder-details');

            if (!clientId) {
                folderDetails.classList.add('hidden');
                return;
            }
            if (!userId) {
                showMessage("Erreur", "Authentification non terminée. Veuillez patienter.");
                return;
            }

            showLoading("Chargement du dossier client...");

            try {
                const clientDocRef = getClientDocRef(clientId);
                const clientDoc = await getDoc(clientDocRef);

                if (clientDoc.exists()) {
                    const clientData = clientDoc.data();
                    let contentHTML = `<h4 class="text-xl font-bold mb-2">${clientData.name}</h4>`;
                    
                    if (clientData.meetings && clientData.meetings.length > 0) {
                        contentHTML += `<h5 class="text-lg font-semibold mt-4 mb-2">Historique des réunions</h5>`;
                        clientData.meetings.forEach(meeting => {
                            contentHTML += `<p class="mb-1 text-gray-700"><strong>${meeting.date} à ${meeting.time}</strong>: ${meeting.notes}</p>`;
                        });
                    } else {
                        contentHTML += `<p class="text-gray-500">Aucune réunion enregistrée.</p>`;
                    }

                    if (clientData.contracts && clientData.contracts.length > 0) {
                        contentHTML += `<h5 class="text-lg font-semibold mt-4 mb-2">Contrats</h5>`;
                        clientData.contracts.forEach(contract => {
                            contentHTML += `<div class="p-4 bg-white rounded-lg border border-gray-200 mt-2">`;
                            contentHTML += `Contrat du ${new Date(contract.date).toLocaleDateString()}<br>`;
                            contentHTML += `<button onclick="this.nextElementSibling.classList.toggle('hidden');" class="text-indigo-600 hover:underline">Voir le contrat</button>`;
                            contentHTML += `<div class="prose max-w-full mt-2 hidden">`;
                            contentHTML += marked.parse(contract.content);
                            contentHTML += `</div></div>`;
                        });
                    } else {
                        contentHTML += `<p class="text-gray-500">Aucun contrat enregistré.</p>`;
                    }
                    
                    folderContent.innerHTML = contentHTML;
                    folderDetails.classList.remove('hidden');
                } else {
                    showMessage("Erreur", "Ce dossier client n'existe pas.");
                    folderDetails.classList.add('hidden');
                }
            } catch (error) {
                console.error("Error fetching client folder:", error);
                showMessage("Erreur", "Une erreur est survenue lors du chargement du dossier.");
            } finally {
                hideLoading();
            }
        });

        // Feature 6: Calendar Manager with AI
        document.getElementById('manage-calendar-btn').addEventListener('click', async () => {
            const calendarPrompt = document.getElementById('calendar-prompt').value;
            if (!calendarPrompt) {
                showMessage("Erreur", "Veuillez décrire une tâche ou un objectif.");
                return;
            }

            showLoading("Génération de suggestions pour le calendrier...");

            const systemPrompt = `
                Tu es un assistant AI de gestion de calendrier pour un professionnel.
                Ton objectif est d'analyser une demande et de fournir des suggestions actionnables pour organiser le calendrier.
                Les suggestions doivent être en français, claires et organisées en une liste à puces.
                Pour chaque suggestion, inclure l'action, le jour, l'heure et la raison.
            `;
            const userQuery = `
                En tant que consultant, voici ma situation et ma demande : ${calendarPrompt}.
                Fournis-moi des suggestions précises pour organiser mon calendrier, en incluant des actions, des jours et des heures spécifiques, ainsi que la raison.
            `;

            try {
                const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        contents: [{ parts: [{ text: userQuery }] }],
                        systemInstruction: { parts: [{ text: systemPrompt }] },
                    })
                });

                const result = await response.json();
                const text = result.candidates?.[0]?.content?.parts?.[0]?.text;

                if (text) {
                    document.getElementById('calendarOutput').innerHTML = marked.parse(text);
                } else {
                    showMessage("Aucun résultat", "Impossible de générer des suggestions pour le moment.");
                }
            } catch (error) {
                console.error("Error managing calendar:", error);
                showMessage("Erreur de connexion", "Une erreur est survenue lors de la communication avec le service AI. Veuillez réessayer plus tard.");
            } finally {
                hideLoading();
            }
        });

        // New Feature: Project Idea Generator
        document.getElementById('generate-project-idea-btn').addEventListener('click', async () => {
            const clientName = document.getElementById('project-name').value;
            const projectIdea = document.getElementById('project-idea').value;

            if (!clientName || !projectIdea) {
                showMessage("Erreur", "Veuillez entrer le nom du client et la description de l'idée de projet.");
                return;
            }

            showLoading("Génération du plan de projet...");

            const systemPrompt = `
                Tu es un consultant en stratégie d'entreprise et en marketing.
                Ton objectif est de transformer une idée de projet simple en un plan d'affaires structuré et détaillé.
                Le plan doit inclure les sections suivantes, formatées en Markdown :
                1.  **Synthèse du Projet** : Une brève introduction au projet.
                2.  **Analyse SWOT** : Analyse des forces, faiblesses, opportunités et menaces.
                3.  **Plan de mise en œuvre** : Étapes clés du projet.
                4.  **Stratégie Marketing** : Un aperçu des canaux et des tactiques de marketing.
                5.  **Calendrier Prévisionnel** : Un calendrier simple avec les principales étapes.
                Toute la réponse doit être en français, rédigée de manière professionnelle et analytique.
            `;

            const userQuery = `
                Pour le client "${clientName}", génère un plan d'affaires détaillé pour le projet suivant :
                ${projectIdea}
            `;

            try {
                const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        contents: [{ parts: [{ text: userQuery }] }],
                        systemInstruction: { parts: [{ text: systemPrompt }] },
                    })
                });

                const result = await response.json();
                const text = result.candidates?.[0]?.content?.parts?.[0]?.text;

                if (text) {
                    document.getElementById('projectOutput').innerHTML = marked.parse(text);
                } else {
                    showMessage("Aucun résultat", "Impossible de générer le plan de projet.");
                }
            } catch (error) {
                console.error("Error generating project idea:", error);
                showMessage("Erreur de connexion", "Une erreur est survenue lors de la communication avec le service AI. Veuillez réessayer plus tard.");
            } finally {
                hideLoading();
            }
        });
    </script>
</body>
</html>